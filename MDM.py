# Check for Optimality of the Solution Generated by LCM or VAM and Modify if not optimal to 
# generate a optimal solution
import numpy as np
cost_mat = np.array([
  [19, 30, 50, 10],
  [70, 30, 40, 60],
  [40, 8, 70, 20],
])
supplies = [7, 9, 18]
demands = [5, 8, 7, 14]
uRows = [None for i in range(np.size(cost_mat, 0))]
vCols = [None for i in range(np.size(cost_mat, 1))]
allocatedCells = np.array([[[None, False] for j in vCols] for i in uRows])
allocatedCells[0, 0] = [5, True]
allocatedCells[0, 3] = [2, True]
allocatedCells[1, 3] = [2, True]
allocatedCells[1, 2] = [7, True]
allocatedCells[2, 1] = [8, True]
allocatedCells[2, 3] = [10, True]
maxRow = [0, 0]
maxCol = [0, 0]
# Getting Rows with Maximum Allocated Cells
for i in range(len(allocatedCells)):
  currRowMax = 0
  for j in range(len(allocatedCells[i])):
    if allocatedCells[i][j][0] != None:
      currRowMax += 1
  if currRowMax > maxRow[0]:
    maxRow[0] = currRowMax
    maxRow[1] = i
# Getting Cols with Maximum Allocated Cells
for i in range(len(allocatedCells.T)):
  currColMax = 0
  for j in range(len(allocatedCells.T[i])):
    if allocatedCells[i, j][0] != None:
      currColMax += 1
  if currColMax > maxCol[0]:
    maxCol[0] = currColMax
    maxCol[1] = i
# Comparing Max of Rows and Cols with Maximum Allocated Cells
# And Assigning the corresponding Row/Col's u/v value as 0
if maxRow[0] > maxCol[0]:
  uRows[maxRow[1]] = 0
else:
  vCols[maxCol[1]] = 0
# Iterating while all the u, v values are filled
while (None in uRows) or (None in vCols):
  for i in range(len(allocatedCells)):
    for j in range(len(allocatedCells[i])):
      if allocatedCells[i, j][0] != None:
        # if u value can be calculated (i.e. corresponding v value present)
        if (vCols[j] != None):
          uRows[i] = cost_mat[i, j] - vCols[j]
        # if v value can be calculated (i.e. corresponding u value present)
        elif (uRows[i] != None):
          vCols[j] = cost_mat[i, j] - uRows[i]
      j += 1
    i += 1
# Calculating Oppurtunity Costs of the Remaining
for i in range(len(allocatedCells)):
  for j in range(len(allocatedCells[i])):
    if allocatedCells[i, j][0] == None:
      allocatedCells[i, j][0] = cost_mat[i, j] - uRows[i] - vCols[j]
print (allocatedCells)
greatestNegative = {
  "value": 0,
  "row": 0,
  "col": 0
}
for i in range(len(allocatedCells)):
  for j in range(len(allocatedCells[i])):
    if allocatedCells[i, j][0] < 0:
      if allocatedCells[i, j][0] < greatestNegative['value']:
        greatestNegative["value"] = allocatedCells[i, j][0]
        greatestNegative["row"] = i
        greatestNegative["col"] = j
if greatestNegative["value"] == 0:
  print ("OPTIMAL SOLUTION FOUND!!")
else:
  # Find Cycle by making a graph with edges as all the paths possible from the greatest negative node
  top = []
  bottom = []
  left = []
  right = [] 
  for i in range(len(allocatedCells[0:greatestNegative["row"], greatestNegative["col"]])):
    if allocatedCells[0:greatestNegative["row"], greatestNegative["col"]][i][1] == True:
      top.append(i)
  for i in range(len(allocatedCells[greatestNegative["row"]:, greatestNegative["col"]])):
    if allocatedCells[greatestNegative["row"]:, greatestNegative["col"]][i][1] == True:
      bottom.append(i)
  for i in range(len(allocatedCells[greatestNegative["row"], 0:greatestNegative["col"]])):
    if allocatedCells[greatestNegative["row"], 0:greatestNegative["col"]][i][1] == True:
      left.append(i)
  for i in range(len(allocatedCells[greatestNegative["row"], greatestNegative["col"]:])):
    if allocatedCells[greatestNegative["row"], greatestNegative["col"]:][i][1] == True:
      right.append(i)
  print (top, bottom, left, right)
